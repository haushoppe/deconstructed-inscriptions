<!DOCTYPE html>
<html>

<head>
  <style type="text/css">
    body {
      background: black;
      margin: 0;
      overflow: hidden;
    }

    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    #indicator {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 100;
    }
  </style>


  <script src="/content/b6a50f5ba932b0ea7f652d9d28e59eced47bc6f8376c25e02d8b3457bb60ac8fi0"></script>
  <script src="/content/a499bb004988202e0e4e6be6dbe9a8dd28fc9565b5182f78a25cfea7d4ee4c67i0"></script>
  <script src="/content/44740a1f30efb247ef41de3355133e12d6f58ab4dc8a3146648e2249fa9c6a39i0"></script>
  <script>

    // ** main glitch

    const img = '/content/45f869235d71180f0c5dab27331b6b61331e25a57a387308cc9db5d9319d39b9i0';
    let g;

    // ** slice image

    let originalImg;
    let workingImg;
    let buffer; // A p5.Graphics object for off-screen drawing and image manipulation
    let iterationCount = 0;

    // ** glitch sound

    let noise, noiseFilter;
    let soundInitialized = false;
    let soundActive = false;

    function calculateFitSize(imgWidth, imgHeight, canvasWidth, canvasHeight) {
      const imgRatio = imgWidth / imgHeight;
      const canvasRatio = canvasWidth / canvasHeight;
      let w, h;

      if (canvasRatio > imgRatio) {
        h = canvasHeight;
        w = h * imgRatio;
      } else {
        w = canvasWidth;
        h = w / imgRatio;
      }

      return { w, h };
    }

    function displayGlitchedImage() {
      const { w, h } = calculateFitSize(g.image.width, g.image.height, width, height);
      image(g.image, width / 2 - w / 2, height / 2 - h / 2, w, h);
    }

    function setup() {
      let canvas = createCanvas(windowWidth, windowHeight);
      canvas.parent('container');
      noSmooth();
      frameRate(20);
      g = new Glitch();
      loadImage(img, (img) => {

        originalImg = img.get();
        workingImg = originalImg.get();

        // creates a hidden canvas (offscreen buffer)
        buffer = createGraphics(originalImg.width, originalImg.height);
        g.loadImage(workingImg);
      });
    }

    function draw() {
      applyGlitch();
      displayGlitchedImage();
    }

    let noiseStormCounter = 0;

    function applyGlitch() {

      const rand = Math.floor(random(0, 4));

      // more than 3 times "rand > 2" makes a longer period of noise (because it's not stopped)
      // when there is a "storm" we also rearrange the image
      if (rand > 2) {
        noiseStormCounter++;
      } else {
        noiseStormCounter = 0;
      }

      if (noiseStormCounter > 2) {
        rearrangeImage();
      }

      g.resetBytes();
      g.randomBytes(rand);
      g.buildImage();
      triggerGlitchSound(rand);
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }

    function rearrangeImage() {

      if (!workingImg) { return; }

      // reset
      if (iterationCount >= 5) {
        workingImg = originalImg.get();
        iterationCount = 0;
      } else {

        const sliceHeight = Math.floor(random(10, workingImg.height / 4));
        const sliceY = Math.floor(random(0, workingImg.height - sliceHeight));

        buffer.clear();
        buffer.image(workingImg, 0, sliceHeight, workingImg.width, sliceY, 0, 0, workingImg.width, sliceY);
        buffer.image(workingImg, 0, 0, workingImg.width, sliceHeight, 0, sliceY, workingImg.width, sliceHeight);
        buffer.image(workingImg, 0, sliceY + sliceHeight, workingImg.width, workingImg.height - sliceY - sliceHeight, 0, sliceY + sliceHeight, workingImg.width, workingImg.height - sliceY - sliceHeight);
        workingImg = buffer.get();

        iterationCount++;
      }

      g.loadImage(workingImg);
    }

    async function initializeGlitchSound() {
      if (soundInitialized) return;

      await Tone.start();

      noise = new Tone.Noise('white').start();
      noiseFilter = new Tone.AutoFilter({
        frequency: '6000n',
        baseFrequency: 200,
        octaves: 2
      }).toDestination();

      noise.connect(noiseFilter);
      noiseFilter.start();

      soundInitialized = true;
    }

    function triggerGlitchSound(rand) {
      if (!soundInitialized) { return; }

      noiseFilter.baseFrequency = 200 * rand;

      if (rand > 2 || soundActive) {
        noise.start();
      } else {
        noise.stop();
      }
    }
  </script>
</head>

<body>

  <div id="container">
    <span id="indicator">ðŸ”ˆ</span>
  </div>

  <script>
    const container = document.getElementById('container');
    const indicator = document.getElementById('indicator');

    async function toggleSound() {
      await initializeGlitchSound();
      soundActive = !soundActive;
      indicator.textContent = soundActive ? 'ðŸ”ˆ' : 'ðŸ”‡';
      indicator.style.opacity = soundActive ? '0.5' : '1';
    }

    document.addEventListener('keydown', async (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        await toggleSound();
      }
    });

    container.addEventListener('click', async () => await toggleSound());

  </script>
</body>

</html>